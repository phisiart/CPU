
// This ROM is automatically generated by the assembler.

module ROM(
    input [31:0] addr,
    output reg[31:0] data
);

    always @(*) begin
        case (addr)
        32'h00400000: data = 32'h00000000; // nop
        32'h00400004: data = 32'h8FB00000; // lw $s0 0($sp)
        32'h00400008: data = 32'hAFB00000; // sw $s0 0($sp)
        32'h0040000C: data = 32'h3C10000A; // lui $s0 10
        32'h00400010: data = 32'h02328020; // add $s0 $s1 $s2
        32'h00400014: data = 32'h02328021; // addu $s0 $s1 $s2
        32'h00400018: data = 32'h02328022; // sub $s0 $s1 $s2
        32'h0040001C: data = 32'h02328023; // subu $s0 $s1 $s2
        32'h00400020: data = 32'h2230000A; // addi $s0 $s1 10
        32'h00400024: data = 32'h2630000A; // addiu $s0 $s1 10
        32'h00400028: data = 32'h02328024; // and $s0 $s1 $s2
        32'h0040002C: data = 32'h02328025; // or $s0 $s1 $s2
        32'h00400030: data = 32'h02328026; // xor $s0 $s1 $s2
        32'h00400034: data = 32'h02328027; // nor $s0 $s1 $s2
        32'h00400038: data = 32'h3230000A; // andi $s0 $s1 10
        32'h0040003C: data = 32'h00118140; // sll $s0 $s1 5
        32'h00400040: data = 32'h00118142; // srl $s0 $s1 5
        32'h00400044: data = 32'h00118143; // sra $s0 $s1 5
        32'h00400048: data = 32'h0232802A; // slt $s0 $s1 $s2
        32'h0040004C: data = 32'h2A300005; // slti $s0 $s1 5
        32'h00400050: data = 32'h2E300005; // sltiu $s0 $s1 5
        32'h00400054: data = 32'h1210FFFE; // beq $s0 $s0 LOC
        32'h00400058: data = 32'h1610FFFD; // bne $s0 $s0 LOC
        32'h0040005C: data = 32'h1A00FFFC; // blez $s0 LOC
        32'h00400060: data = 32'h1E00FFFB; // bgtz $s0 LOC
        32'h00400064: data = 32'h0600FFFA; // bltz $s0 LOC
        32'h00400068: data = 32'h08100014; // j LOC
        32'h0040006C: data = 32'h0C100014; // jal LOC
        32'h00400070: data = 32'h03E00008; // jr $ra
        32'h00400074: data = 32'h03E0F809; // jalr $ra $ra

        default: data = 32'hCCCCCCCC;
        endcase
    end

endmodule

    